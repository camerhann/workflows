# Issue Agent - 4-Agent AI Pipeline with Ralph-Style Retry Loop
name: Issue Agent (Reusable)

on:
  # Direct triggers (for workflows repo itself)
  issues:
    types: [opened, labeled]
  issue_comment:
    types: [created]

  # Reusable workflow trigger (for other repos)
  workflow_call:
    secrets:
      ANTHROPIC_API_KEY:
        required: true

env:
  MAX_WRITER_ATTEMPTS: 3  # Ralph-style iteration limit

jobs:
  work-on-issue:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Claude Code
        run: npm install -g @anthropic-ai/claude-code

      - name: Configure Git
        run: |
          git config user.name "Claude Agent"
          git config user.email "claude-agent@users.noreply.github.com"

      - name: Setup Branch
        run: |
          ISSUE_NUMBER=${{ github.event.issue.number }}
          BRANCH_NAME="agent/issue-${ISSUE_NUMBER}"
          git checkout -b "$BRANCH_NAME"
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
          echo "ISSUE_NUMBER=$ISSUE_NUMBER" >> $GITHUB_ENV

      - name: Get Issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue view ${{ github.event.issue.number }} --json title,body > issue.json

      # ========================================
      # STEP 1: ISSUE ANALYST (with Promise)
      # ========================================
      - name: Issue Analyst
        id: analyst
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ISSUE_TITLE=$(jq -r '.title' issue.json)
          ISSUE_BODY=$(jq -r '.body' issue.json)

          OUTPUT=$(claude --print --dangerously-skip-permissions "
          You are the ISSUE ANALYST. Your job is to research the codebase and create a clear brief.

          ## Core Philosophy
          The Writer should never have to guess what to do.

          ## Issue #${{ env.ISSUE_NUMBER }}
          **Title:** $ISSUE_TITLE
          **Description:** $ISSUE_BODY

          ## Your Tasks
          1. Research the codebase - find relevant files, patterns, and existing implementations
          2. Identify which files need to be modified
          3. Find existing patterns to follow (search for similar implementations)
          4. **Classify the issue type** and identify test requirements
          5. Create a file called ANALYSIS.md with:
             - Issue type (BUG_FIX, NEW_FEATURE, or REFACTOR_STYLE)
             - Relevant files (table with file path, purpose, action needed)
             - Existing patterns to follow
             - Must Do requirements
             - Must NOT Do boundaries
             - Scope estimate (SMALL/MEDIUM/LARGE)
             - **Test Requirement section** (see below)

          ## Issue Type Classification
          - **BUG_FIX**: Something is broken and needs fixing
          - **NEW_FEATURE**: Adding new functionality
          - **REFACTOR_STYLE**: Code cleanup, no behavior change (NO test required)

          ## Test Requirement Section (REQUIRED in ANALYSIS.md)
          For BUG_FIX:
          \`\`\`
          ### Test Requirement
          **Type:** BUG_FIX - Test required
          **Test location:** [path to existing test file, or new file if none exists]
          **Test description:** Write a regression test that would have caught this bug
          **What to test:** [specific behavior that was broken]
          \`\`\`

          For NEW_FEATURE:
          \`\`\`
          ### Test Requirement
          **Type:** NEW_FEATURE - Test required
          **Test location:** [path to test file]
          **Test description:** Write a test that proves the feature works
          **What to test:** [the happy path of the new feature]
          \`\`\`

          For REFACTOR_STYLE:
          \`\`\`
          ### Test Requirement
          **Type:** REFACTOR_STYLE - No new test required
          **Note:** Existing tests must still pass
          \`\`\`

          ## Constraints
          - Do NOT write any code yet
          - Do NOT modify any source files
          - ONLY create ANALYSIS.md with your findings
          - Be specific - vague briefs lead to wrong solutions

          ## Completion Signal
          When ANALYSIS.md is complete and thorough, output exactly:
          <promise>ANALYSIS_COMPLETE</promise>

          If you cannot complete analysis (missing info, unclear requirements), output:
          <promise>ANALYSIS_BLOCKED: [reason]</promise>
          ")

          echo "$OUTPUT"

          # Check for promise signals
          if echo "$OUTPUT" | grep -q "<promise>ANALYSIS_COMPLETE</promise>"; then
            echo "status=complete" >> $GITHUB_OUTPUT
          elif echo "$OUTPUT" | grep -q "<promise>ANALYSIS_BLOCKED"; then
            BLOCK_REASON=$(echo "$OUTPUT" | grep -o '<promise>ANALYSIS_BLOCKED: [^<]*</promise>' | sed 's/<[^>]*>//g')
            echo "status=blocked" >> $GITHUB_OUTPUT
            echo "reason=$BLOCK_REASON" >> $GITHUB_OUTPUT
          else
            echo "status=complete" >> $GITHUB_OUTPUT  # Default to complete for backwards compat
          fi

      - name: Handle Analyst Block
        if: steps.analyst.outputs.status == 'blocked'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue comment ${{ env.ISSUE_NUMBER }} --body "ðŸ¤– **Issue Analyst Blocked**

          Could not complete analysis:
          > ${{ steps.analyst.outputs.reason }}

          Please provide more details in the issue description."
          exit 1

      # ========================================
      # STEP 2 & 3: WRITER-REVIEWER RETRY LOOP
      # Ralph-style iteration with feedback
      # ========================================
      - name: Writer-Reviewer Loop
        id: write_review
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          ISSUE_TITLE=$(jq -r '.title' issue.json)
          ISSUE_BODY=$(jq -r '.body' issue.json)

          # Read analysis
          ANALYSIS=""
          if [[ -f ANALYSIS.md ]]; then
            ANALYSIS=$(cat ANALYSIS.md)
          fi

          # Initialize feedback for first iteration
          PREVIOUS_FEEDBACK=""
          ATTEMPT=1
          APPROVED=false

          # ====== RALPH-STYLE RETRY LOOP ======
          while [[ $ATTEMPT -le ${{ env.MAX_WRITER_ATTEMPTS }} ]]; do
            echo "=========================================="
            echo "ðŸ”„ ATTEMPT $ATTEMPT of ${{ env.MAX_WRITER_ATTEMPTS }}"
            echo "=========================================="

            # Reset changes if this is a retry
            if [[ $ATTEMPT -gt 1 ]]; then
              echo "Resetting changes for retry..."
              git checkout -- . 2>/dev/null || true
              git clean -fd 2>/dev/null || true
            fi

            # ------ WRITER AGENT ------
            echo ">>> Running Writer Agent..."

            WRITER_OUTPUT=$(claude --print --dangerously-skip-permissions "
            You are the WRITER AGENT. Your job is to make SURGICAL, MINIMAL changes.

            ## Iteration Info
            **Attempt:** $ATTEMPT of ${{ env.MAX_WRITER_ATTEMPTS }}
            ${PREVIOUS_FEEDBACK:+**Previous Rejection Feedback:** $PREVIOUS_FEEDBACK}

            ## Core Philosophy
            The best code change is the smallest one that solves the problem.
            - The existing codebase is the authority - learn from it, don't fight it
            - Every line you add should earn its place
            - If the existing code does something a certain way, do it that way too
            - **Untested code is incomplete code** - a fix without a test is not done
            ${PREVIOUS_FEEDBACK:+- **IMPORTANT:** Address the reviewer feedback above!}

            ## Issue #${{ env.ISSUE_NUMBER }}
            **Title:** $ISSUE_TITLE
            **Description:** $ISSUE_BODY

            ## Analysis from Issue Analyst
            $ANALYSIS

            ## Your Tasks
            1. Study the existing code patterns BEFORE writing anything
            2. Make the MINIMUM viable change that solves the issue
            3. Match existing code style exactly
            4. **Write ONE test if required** (see Test Requirement section in Analysis)
               - For BUG_FIX: Write a regression test that catches the bug
               - For NEW_FEATURE: Write a test that proves the feature works
               - For REFACTOR_STYLE: No new test needed (existing tests must pass)
            5. Save your changes (do NOT commit)
            ${PREVIOUS_FEEDBACK:+6. **Address reviewer feedback from previous attempt**}

            ## Test Guidelines
            - Write exactly ONE focused test - not a test suite
            - Test the specific thing that was fixed or added
            - Follow existing test patterns in the codebase
            - Place test in the location specified by the Analyst
            - The test IS part of the minimum viable change

            ## Constraints
            - Do NOT commit your changes
            - Do NOT refactor existing code unless required
            - Do NOT add features beyond what the issue requests
            - Do NOT improve code style in files you're touching
            - Do NOT write multiple tests - just ONE that proves your change works
            - When in doubt, do less

            ## Self-Review Checklist (verify before finishing)
            - Are changes the smallest possible?
            - Did you follow existing patterns?
            - Does your code look like it belongs?
            - If BUG_FIX or NEW_FEATURE: Did you write ONE test?
            ${PREVIOUS_FEEDBACK:+- Did you address the reviewer feedback?}

            ## Completion Signal
            When done, output exactly:
            <promise>CHANGES_READY</promise>
            ")

            echo "$WRITER_OUTPUT"

            # Check if writer produced changes
            git diff > changes.diff
            if [[ ! -s changes.diff ]]; then
              echo "No changes produced by Writer"
              ATTEMPT=$((ATTEMPT + 1))
              PREVIOUS_FEEDBACK="Writer produced no changes. Please make the necessary code modifications."
              continue
            fi

            # ------ REVIEWER AGENT ------
            echo ">>> Running Reviewer Agent..."

            REVIEWER_OUTPUT=$(claude --print --dangerously-skip-permissions "
            You are the REVIEWER AGENT. You are the QUALITY GATEKEEPER.

            ## Iteration Info
            **Attempt:** $ATTEMPT of ${{ env.MAX_WRITER_ATTEMPTS }}

            ## Core Philosophy
            Nothing gets through unless it's verified.
            - You don't trust - you verify
            - If anything looks wrong, REJECT with specific, actionable feedback
            - Your feedback will be given to Writer for the next attempt
            - **A fix without a test is not complete** (for bugs and features)

            ## Issue Being Solved
            **Title:** $ISSUE_TITLE
            **Description:** $ISSUE_BODY

            ## Analysis from Issue Analyst
            $ANALYSIS

            ## Changes to Review
            \`\`\`diff
            $(cat changes.diff)
            \`\`\`

            ## Your Tasks
            1. Review the code changes
            2. Check for bugs, security issues, logic errors
            3. Verify changes are minimal and focused
            4. Check that existing patterns were followed
            5. **Verify test requirement is met** (see below)

            ## Test Verification
            Check the 'Test Requirement' section in the Analysis above:
            - If **BUG_FIX**: There MUST be a test that would catch the bug
            - If **NEW_FEATURE**: There MUST be a test that proves the feature works
            - If **REFACTOR_STYLE**: No new test required

            If a test is required but missing, REJECT with:
            'Missing required test. This is a [BUG_FIX/NEW_FEATURE] - write ONE test that [specific guidance].'

            ## Judgment - Output EXACTLY ONE of these:

            If APPROVED (all criteria met):
            <promise>APPROVED</promise>

            If REJECTED (any issues found):
            <promise>REJECTED: [specific, actionable feedback for Writer]</promise>

            ## REJECT if ANY of these are true:
            - Changes are bloated or unfocused
            - Bugs or security issues found
            - Doesn't solve the actual issue
            - Introduces unnecessary complexity
            - Doesn't follow existing codebase patterns
            - **Missing required test** (for BUG_FIX or NEW_FEATURE)

            ## APPROVE only if ALL are true:
            - Changes are minimal and focused
            - Solution solves the issue
            - No obvious bugs or security issues
            - Follows existing codebase patterns
            - **Test requirement is satisfied** (if applicable)
            ")

            echo "$REVIEWER_OUTPUT"

            # Parse reviewer decision
            if echo "$REVIEWER_OUTPUT" | grep -q "<promise>APPROVED</promise>"; then
              echo "âœ… APPROVED on attempt $ATTEMPT"
              APPROVED=true
              break
            elif echo "$REVIEWER_OUTPUT" | grep -q "<promise>REJECTED:"; then
              PREVIOUS_FEEDBACK=$(echo "$REVIEWER_OUTPUT" | grep -o '<promise>REJECTED: [^<]*</promise>' | sed 's/<promise>REJECTED: //' | sed 's/<\/promise>//')
              echo "âŒ REJECTED: $PREVIOUS_FEEDBACK"
              echo "Will retry with feedback..."
            else
              # No clear signal, default to needing another attempt
              PREVIOUS_FEEDBACK="Reviewer did not provide clear approval. Please ensure changes are minimal and correct."
              echo "âš ï¸ Unclear response, retrying..."
            fi

            ATTEMPT=$((ATTEMPT + 1))
          done
          # ====== END RETRY LOOP ======

          # Clean up
          rm -f ANALYSIS.md changes.diff

          # Set outputs
          if [[ "$APPROVED" == "true" ]]; then
            echo "approved=true" >> $GITHUB_OUTPUT
            echo "attempts=$ATTEMPT" >> $GITHUB_OUTPUT
          else
            echo "approved=false" >> $GITHUB_OUTPUT
            echo "attempts=${{ env.MAX_WRITER_ATTEMPTS }}" >> $GITHUB_OUTPUT
            echo "final_feedback=$PREVIOUS_FEEDBACK" >> $GITHUB_OUTPUT
          fi

      # ========================================
      # STEP 4: COMMITTER AGENT (with Promise)
      # ========================================
      - name: Committer Agent
        if: steps.write_review.outputs.approved == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          if [[ -z $(git status --porcelain) ]]; then
            gh issue comment ${{ env.ISSUE_NUMBER }} --body "ðŸ¤– Analyzed the issue but couldn't determine what changes to make. Please provide more details."
            exit 0
          fi

          ISSUE_TITLE=$(jq -r '.title' issue.json)
          ATTEMPTS="${{ steps.write_review.outputs.attempts }}"

          # Get a smart commit message from Claude
          git diff --staged > /dev/null 2>&1 || git add -A
          DIFF_SUMMARY=$(git diff --cached --stat)

          COMMIT_MSG=$(claude --print --dangerously-skip-permissions "
          Generate a conventional commit message for these changes.

          Issue: #${{ env.ISSUE_NUMBER }} - $ISSUE_TITLE

          Changes:
          $DIFF_SUMMARY

          Rules:
          - Use format: type(scope): description
          - Types: feat, fix, refactor, style, docs, test, chore
          - Be specific, not generic
          - End with: Closes #${{ env.ISSUE_NUMBER }}

          Output ONLY the commit message, nothing else.
          Then output: <promise>COMMIT_READY</promise>
          ")

          # Extract just the commit message (before the promise)
          COMMIT_MSG=$(echo "$COMMIT_MSG" | sed 's/<promise>.*<\/promise>//' | xargs)

          git add -A
          git commit -m "$COMMIT_MSG"
          git push -u origin "${{ env.BRANCH_NAME }}"

          # Determine iteration note
          if [[ "$ATTEMPTS" == "1" ]]; then
            ITERATION_NOTE="âœ… Approved on first attempt"
          else
            ITERATION_NOTE="ðŸ”„ Approved after $ATTEMPTS attempts (Ralph-style retry)"
          fi

          gh pr create \
            --title "Fix #${{ env.ISSUE_NUMBER }}: $ISSUE_TITLE" \
            --body "## Summary
          Automated fix for #${{ env.ISSUE_NUMBER }}

          ## Changes
          $DIFF_SUMMARY

          ## Pipeline Results
          - **Issue Analyst:** âœ… Research complete (with test requirements)
          - **Writer-Reviewer Loop:** $ITERATION_NOTE
          - **Test Coverage:** âœ… Test included (if required for issue type)
          - **Committer Agent:** âœ… PR created

          ## Next Steps
          1. Review this PR
          2. Merge to \`develop\` when approved
          3. Manually merge \`develop\` â†’ \`main\` when ready
          4. Close issue #${{ env.ISSUE_NUMBER }} after merged to main

          Related to #${{ env.ISSUE_NUMBER }}

          ---
          ðŸ¤– Generated by Claude Agent Pipeline (with test-what-you-touch policy)" \
            --base develop

          echo "<promise>PR_CREATED</promise>"

      # ========================================
      # HANDLE MAX RETRIES EXHAUSTED
      # ========================================
      - name: Handle Retry Exhaustion
        if: steps.write_review.outputs.approved == 'false'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh issue comment ${{ env.ISSUE_NUMBER }} --body "ðŸ¤– **Agent Pipeline Failed After ${{ env.MAX_WRITER_ATTEMPTS }} Attempts**

          The Writer-Reviewer loop could not produce approved changes.

          **Final Feedback:**
          > ${{ steps.write_review.outputs.final_feedback }}

          **Possible Actions:**
          1. Simplify the issue requirements
          2. Add more specific acceptance criteria
          3. Break into smaller issues
          4. Handle manually

          ---
          ðŸ”„ Ralph-style retry loop exhausted"
